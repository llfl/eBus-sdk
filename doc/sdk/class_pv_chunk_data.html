<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvChunkData Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v5.1.10.4642 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_pv_chunk_data.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pv_chunk_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvChunkData Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Raw data interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>.  
 <a href="class_pv_chunk_data.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adaa692b9fede1ea8663f16aa8eb4a07a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#adaa692b9fede1ea8663f16aa8eb4a07a">GetChunkDataPayloadLength</a> () const </td></tr>
<tr class="memdesc:adaa692b9fede1ea8663f16aa8eb4a07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk data payload length specified in the trailer information of this block.  <a href="#adaa692b9fede1ea8663f16aa8eb4a07a">More...</a><br /></td></tr>
<tr class="separator:adaa692b9fede1ea8663f16aa8eb4a07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17112de8a2f06aaa4a0edfb1f4c37186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a17112de8a2f06aaa4a0edfb1f4c37186">Alloc</a> (uint32_t aMaximumChunkLength)</td></tr>
<tr class="memdesc:a17112de8a2f06aaa4a0edfb1f4c37186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a>.  <a href="#a17112de8a2f06aaa4a0edfb1f4c37186">More...</a><br /></td></tr>
<tr class="separator:a17112de8a2f06aaa4a0edfb1f4c37186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d672ffed3757f33df21308bcbd319cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d672ffed3757f33df21308bcbd319cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a4d672ffed3757f33df21308bcbd319cd">Free</a> ()</td></tr>
<tr class="memdesc:a4d672ffed3757f33df21308bcbd319cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory. <br /></td></tr>
<tr class="separator:a4d672ffed3757f33df21308bcbd319cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378d72419361aaf59c34d5387b0331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a8e378d72419361aaf59c34d5387b0331">Attach</a> (void *aRawBuffer, uint32_t aMaximumChunkLength)</td></tr>
<tr class="memdesc:a8e378d72419361aaf59c34d5387b0331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> to an external memory buffer.  <a href="#a8e378d72419361aaf59c34d5387b0331">More...</a><br /></td></tr>
<tr class="separator:a8e378d72419361aaf59c34d5387b0331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af352875f86311148a1362d126be00351"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#af352875f86311148a1362d126be00351">Detach</a> ()</td></tr>
<tr class="memdesc:af352875f86311148a1362d126be00351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="#af352875f86311148a1362d126be00351">More...</a><br /></td></tr>
<tr class="separator:af352875f86311148a1362d126be00351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43db4cea3a518e1a6749667855cce1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a43db4cea3a518e1a6749667855cce1f8">AddChunk</a> (uint32_t aID, const uint8_t *aData, uint32_t aLength)</td></tr>
<tr class="memdesc:a43db4cea3a518e1a6749667855cce1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec" title="Add chunk data to the buffer. ">PvBuffer::AddChunk</a>.  <a href="#a43db4cea3a518e1a6749667855cce1f8">More...</a><br /></td></tr>
<tr class="separator:a43db4cea3a518e1a6749667855cce1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bea511e07e3a945dae14d6aa4510c7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a92bea511e07e3a945dae14d6aa4510c7">GetChunkCount</a> ()</td></tr>
<tr class="memdesc:a92bea511e07e3a945dae14d6aa4510c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c" title="Returns the number of data chunks in the PvBuffer. ">PvBuffer::GetChunkCount</a>.  <a href="#a92bea511e07e3a945dae14d6aa4510c7">More...</a><br /></td></tr>
<tr class="separator:a92bea511e07e3a945dae14d6aa4510c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa8796be3fdcb8f93285e78c3ec0f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#affa8796be3fdcb8f93285e78c3ec0f3b">GetChunkIDByIndex</a> (uint32_t aIndex, uint32_t &amp;aID)</td></tr>
<tr class="memdesc:affa8796be3fdcb8f93285e78c3ec0f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a" title="Returns the ID of a chunk based on its index. ">PvBuffer::GetChunkIDByIndex</a>.  <a href="#affa8796be3fdcb8f93285e78c3ec0f3b">More...</a><br /></td></tr>
<tr class="separator:affa8796be3fdcb8f93285e78c3ec0f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25d28fc41237f516ead38d498df2b54"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#ad25d28fc41237f516ead38d498df2b54">GetChunkSizeByIndex</a> (uint32_t aIndex)</td></tr>
<tr class="memdesc:ad25d28fc41237f516ead38d498df2b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6" title="Returns the size in bytes of the data chunk at zero-based aIndex. ">PvBuffer::GetChunkSizeByIndex</a>.  <a href="#ad25d28fc41237f516ead38d498df2b54">More...</a><br /></td></tr>
<tr class="separator:ad25d28fc41237f516ead38d498df2b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87f10ec31fe18be57113be13af6284f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#ad87f10ec31fe18be57113be13af6284f">GetChunkSizeByID</a> (uint32_t aID)</td></tr>
<tr class="memdesc:ad87f10ec31fe18be57113be13af6284f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec" title="Returns the size in bytes of the data chunk identified by aID. ">PvBuffer::GetChunkSizeByID</a>.  <a href="#ad87f10ec31fe18be57113be13af6284f">More...</a><br /></td></tr>
<tr class="separator:ad87f10ec31fe18be57113be13af6284f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee06c860d694700a050cc4371d8675a"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#abee06c860d694700a050cc4371d8675a">GetChunkRawDataByIndex</a> (uint32_t aIndex)</td></tr>
<tr class="memdesc:abee06c860d694700a050cc4371d8675a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176" title="Returns a const pointer to the data chunk at zero-based aIndex. ">PvBuffer::GetChunkRawDataByIndex</a>.  <a href="#abee06c860d694700a050cc4371d8675a">More...</a><br /></td></tr>
<tr class="separator:abee06c860d694700a050cc4371d8675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b24b2f2ccc68d0a8468437f984f5788"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a5b24b2f2ccc68d0a8468437f984f5788">GetChunkRawDataByID</a> (uint32_t aID)</td></tr>
<tr class="memdesc:a5b24b2f2ccc68d0a8468437f984f5788"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae" title="Returns a const pointer to the data chunk with its ID matching aID. ">PvBuffer::GetChunkRawDataByID</a>.  <a href="#a5b24b2f2ccc68d0a8468437f984f5788">More...</a><br /></td></tr>
<tr class="separator:a5b24b2f2ccc68d0a8468437f984f5788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff98ecdab36f9f2c0dcc739b566c2f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#aaff98ecdab36f9f2c0dcc739b566c2f6">PvChunkData</a> (PvBufferLib::ChunkData *aChunkData)</td></tr>
<tr class="memdesc:aaff98ecdab36f9f2c0dcc739b566c2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aaff98ecdab36f9f2c0dcc739b566c2f6">More...</a><br /></td></tr>
<tr class="separator:aaff98ecdab36f9f2c0dcc739b566c2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215fc482f009352bcd66a31b691c5c15"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a215fc482f009352bcd66a31b691c5c15">~PvChunkData</a> ()</td></tr>
<tr class="memdesc:a215fc482f009352bcd66a31b691c5c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a215fc482f009352bcd66a31b691c5c15">More...</a><br /></td></tr>
<tr class="separator:a215fc482f009352bcd66a31b691c5c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Raw data interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> represents a generic buffer with no specific payload type. If the payload type is chunk data, the user can obtain a pointer to a <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> buffer interface through <a class="el" href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb" title="Returns the PvChunkData interface to the buffer. ">PvBuffer::GetChunkData</a>.</p>
<p>This <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> exists.</p>
<p>To use in a receiver context, retrieve <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> from <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> or <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a> and when <a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122" title="Returns the payload type currently used by the buffer. ">PvBuffer::GetPayloadType</a> is PvPayloadChunkData use <a class="el" href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb" title="Returns the PvChunkData interface to the buffer. ">PvBuffer::GetChunkData</a> to retrieve a pointer to this interface. Use the various chunk methods in this class to access the chunk data by ID or index or alternatively attach the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> to the GenApi interface of the transmitter with <a class="el" href="class_pv_gen_parameter_array.html#ab3cbd1ab39d7d2bd8796ef501f88e86b" title="Attaches a payload containing data chunks to a GenICam node map. ">PvGenParameterArray::AttachDataChunks</a> to access the chunk data using GenApi.</p>
<p>To use in a transmitter context, create a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>, set its payload type to PvPayloadChunkData with SetPayloadType, use <a class="el" href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb" title="Returns the PvChunkData interface to the buffer. ">PvBuffer::GetChunkData</a> to retrieve a point to this interface, use <a class="el" href="class_pv_chunk_data.html#a17112de8a2f06aaa4a0edfb1f4c37186" title="Allocates memory for this PvChunkData. ">PvChunkData::Alloc</a> to allocate enough memory for all chunks and their headers (64 bytes per chunk for the headers) and then add chunks to the buffer using <a class="el" href="class_pv_chunk_data.html#a43db4cea3a518e1a6749667855cce1f8" title="See PvBuffer::AddChunk. ">PvChunkData::AddChunk</a>. Use <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol. ">PvTransmitterGEV</a> to transmit the buffer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaff98ecdab36f9f2c0dcc739b566c2f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvChunkData::PvChunkData </td>
          <td>(</td>
          <td class="paramtype">PvBufferLib::ChunkData *&#160;</td>
          <td class="paramname"><em>aChunkData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Declared as protected as <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> cannot be instantiated by the user.</p>
<p>A pointer to the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> interface can be obtained from a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> using PvChunkData::GetImage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkData</td><td>Pointer to internal eBUS SDK class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a215fc482f009352bcd66a31b691c5c15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PvChunkData::~PvChunkData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Declared as protected as the user does no need (or can) delete a <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> directly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a43db4cea3a518e1a6749667855cce1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvChunkData::AddChunk </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec" title="Add chunk data to the buffer. ">PvBuffer::AddChunk</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Chunk data ID for aIndex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aData</td><td>Payload data of the chunk data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aLength</td><td>Length of the payload data of the chunk, in bytes. Must be a multiple of 4 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> is used to capture the success or failure of the operation:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca37cf2b6eb84b2f3286393bc9108cfab4">PvResult::Code::BUFFER_TOO_SMALL</a> There is not enough space in the buffer to add the chunk data.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> One of the input arguments is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a17112de8a2f06aaa4a0edfb1f4c37186"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvChunkData::Alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaximumChunkLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a>. </p>
<p>Allocs a <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> of specific payload length. No extra data can or need to be priovisioned for chunks as the whole payload is made of chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaximumChunkLength</td><td>Maximum size in bytes to store chunk data (must include extra 64 bits for each chunk header).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8e378d72419361aaf59c34d5387b0331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvChunkData::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aRawBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaximumChunkLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer. ">PvChunkData</a> to an external memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRawBuffer</td><td>A pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaximumChunkLength</td><td>Attached buffer size: chunk length sum + 64 bits for each chunk header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af352875f86311148a1362d126be00351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvChunkData::Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's location in memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a92bea511e07e3a945dae14d6aa4510c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvChunkData::GetChunkCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c" title="Returns the number of data chunks in the PvBuffer. ">PvBuffer::GetChunkCount</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="section return"><dt>Returns</dt><dd>Data chunks count. 0 if no chunks are available. </dd></dl>

</div>
</div>
<a class="anchor" id="adaa692b9fede1ea8663f16aa8eb4a07a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvChunkData::GetChunkDataPayloadLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the chunk data payload length specified in the trailer information of this block. </p>
<dl class="section return"><dt>Returns</dt><dd>The payload length specified in the trailer information of this block. </dd></dl>

</div>
</div>
<a class="anchor" id="affa8796be3fdcb8f93285e78c3ec0f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvChunkData::GetChunkIDByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a" title="Returns the ID of a chunk based on its index. ">PvBuffer::GetChunkIDByIndex</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aID</td><td>Data chunk ID for aIndex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> is used to captured the success or failure of the operation as 0 can be a valid chunk ID:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa4357271e02951867594e0cc932c12f8">PvResult::Code::NOT_FOUND</a> if the index is out of range or the buffer does not have any chunks </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5b24b2f2ccc68d0a8468437f984f5788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvChunkData::GetChunkRawDataByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae" title="Returns a const pointer to the data chunk with its ID matching aID. ">PvBuffer::GetChunkRawDataByID</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<p>If the aID chunk is not found or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> does not have any chunks NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point to chunk data. NULL if the chunk ID is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="abee06c860d694700a050cc4371d8675a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvChunkData::GetChunkRawDataByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176" title="Returns a const pointer to the data chunk at zero-based aIndex. ">PvBuffer::GetChunkRawDataByIndex</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point to chunk data. NULL if the index is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="ad87f10ec31fe18be57113be13af6284f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvChunkData::GetChunkSizeByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec" title="Returns the size in bytes of the data chunk identified by aID. ">PvBuffer::GetChunkSizeByID</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the chunk ID is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ad25d28fc41237f516ead38d498df2b54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvChunkData::GetChunkSizeByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6" title="Returns the size in bytes of the data chunk at zero-based aIndex. ">PvBuffer::GetChunkSizeByIndex</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the index is out of range. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_chunk_data_8h_source.html">PvChunkData.h</a></li>
<li>PvChunkData.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2018 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
