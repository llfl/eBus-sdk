<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>IPvDSSource Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v5.1.10.4642 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_i_pv_d_s_source.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_pv_d_s_source-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IPvDSSource Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>COM interface to the eBUS SDK DirectShow Source filter, <a class="el" href="class_pv_d_s_source.html">PvDSSource</a>.  
 <a href="class_i_pv_d_s_source.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27790b0f348b4c1216b3d15fdd8a943c"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a27790b0f348b4c1216b3d15fdd8a943c">get_Role</a> (int *role)</td></tr>
<tr class="memdesc:a27790b0f348b4c1216b3d15fdd8a943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter role read method.  <a href="#a27790b0f348b4c1216b3d15fdd8a943c">More...</a><br /></td></tr>
<tr class="separator:a27790b0f348b4c1216b3d15fdd8a943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f491dcfa596fcd7221cfa1e2af69ad"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a85f491dcfa596fcd7221cfa1e2af69ad">put_Role</a> (int role)</td></tr>
<tr class="memdesc:a85f491dcfa596fcd7221cfa1e2af69ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter role write method.  <a href="#a85f491dcfa596fcd7221cfa1e2af69ad">More...</a><br /></td></tr>
<tr class="separator:a85f491dcfa596fcd7221cfa1e2af69ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e94d5e42b57f5fd11e0e73a94978d5a"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a4e94d5e42b57f5fd11e0e73a94978d5a">get_UnicastPort</a> (int *port)</td></tr>
<tr class="memdesc:a4e94d5e42b57f5fd11e0e73a94978d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter unicast port read method.  <a href="#a4e94d5e42b57f5fd11e0e73a94978d5a">More...</a><br /></td></tr>
<tr class="separator:a4e94d5e42b57f5fd11e0e73a94978d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8a38ae6574f0b11733dae9e4608a30"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a6b8a38ae6574f0b11733dae9e4608a30">put_UnicastPort</a> (int port)</td></tr>
<tr class="memdesc:a6b8a38ae6574f0b11733dae9e4608a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter unicast port write method.  <a href="#a6b8a38ae6574f0b11733dae9e4608a30">More...</a><br /></td></tr>
<tr class="separator:a6b8a38ae6574f0b11733dae9e4608a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa287307eaa89d91eafe9f83573003fe6"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#aa287307eaa89d91eafe9f83573003fe6">get_MulticastIP</a> (BSTR *ip)</td></tr>
<tr class="memdesc:aa287307eaa89d91eafe9f83573003fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter multicast group IP address read method.  <a href="#aa287307eaa89d91eafe9f83573003fe6">More...</a><br /></td></tr>
<tr class="separator:aa287307eaa89d91eafe9f83573003fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13c58ceca470e3aa01723301bc7087c"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ac13c58ceca470e3aa01723301bc7087c">put_MulticastIP</a> (BSTR ip)</td></tr>
<tr class="memdesc:ac13c58ceca470e3aa01723301bc7087c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter multicast group IP address write method.  <a href="#ac13c58ceca470e3aa01723301bc7087c">More...</a><br /></td></tr>
<tr class="separator:ac13c58ceca470e3aa01723301bc7087c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f68fa9ab55eab43dc6c7ea5d11c526"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ac9f68fa9ab55eab43dc6c7ea5d11c526">get_MulticastPort</a> (int *port)</td></tr>
<tr class="memdesc:ac9f68fa9ab55eab43dc6c7ea5d11c526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter multicast group port read method.  <a href="#ac9f68fa9ab55eab43dc6c7ea5d11c526">More...</a><br /></td></tr>
<tr class="separator:ac9f68fa9ab55eab43dc6c7ea5d11c526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dd7e33c089adad5afa292cdca12722"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a56dd7e33c089adad5afa292cdca12722">put_MulticastPort</a> (int port)</td></tr>
<tr class="memdesc:a56dd7e33c089adad5afa292cdca12722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multicast group port to join where the streaming data from the GigE Vision device is received with the multicast role.  <a href="#a56dd7e33c089adad5afa292cdca12722">More...</a><br /></td></tr>
<tr class="separator:a56dd7e33c089adad5afa292cdca12722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad712ed75e8f2a04855eb71f8e2af7da6"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ad712ed75e8f2a04855eb71f8e2af7da6">get_DiagnosticEnabled</a> (BOOL *enabled)</td></tr>
<tr class="memdesc:ad712ed75e8f2a04855eb71f8e2af7da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter diagnostic enabled read method.  <a href="#ad712ed75e8f2a04855eb71f8e2af7da6">More...</a><br /></td></tr>
<tr class="separator:ad712ed75e8f2a04855eb71f8e2af7da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac32cf630fea9a3c00d3ff668477fc63"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#aac32cf630fea9a3c00d3ff668477fc63">put_DiagnosticEnabled</a> (BOOL enabled)</td></tr>
<tr class="memdesc:aac32cf630fea9a3c00d3ff668477fc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter diagnostic enabled write method.  <a href="#aac32cf630fea9a3c00d3ff668477fc63">More...</a><br /></td></tr>
<tr class="separator:aac32cf630fea9a3c00d3ff668477fc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ac8a974084539ae42858275ccdfd45"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a63ac8a974084539ae42858275ccdfd45">get_DeviceID</a> (BSTR *deviceid)</td></tr>
<tr class="memdesc:a63ac8a974084539ae42858275ccdfd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter device ID read method.  <a href="#a63ac8a974084539ae42858275ccdfd45">More...</a><br /></td></tr>
<tr class="separator:a63ac8a974084539ae42858275ccdfd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84949035a36cc4e8f405bf6b7813d8f0"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a84949035a36cc4e8f405bf6b7813d8f0">put_DeviceID</a> (BSTR deviceid)</td></tr>
<tr class="memdesc:a84949035a36cc4e8f405bf6b7813d8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device ID write method.  <a href="#a84949035a36cc4e8f405bf6b7813d8f0">More...</a><br /></td></tr>
<tr class="separator:a84949035a36cc4e8f405bf6b7813d8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cad3fb2dd7cfdd886f5c65ed77b7a38"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a2cad3fb2dd7cfdd886f5c65ed77b7a38">DisconnectDevice</a> ()</td></tr>
<tr class="memdesc:a2cad3fb2dd7cfdd886f5c65ed77b7a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the filter from the device.  <a href="#a2cad3fb2dd7cfdd886f5c65ed77b7a38">More...</a><br /></td></tr>
<tr class="separator:a2cad3fb2dd7cfdd886f5c65ed77b7a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23edec9e874cebcb68cd358fd321dea"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ad23edec9e874cebcb68cd358fd321dea">ConnectIfNeeded</a> ()</td></tr>
<tr class="memdesc:ad23edec9e874cebcb68cd358fd321dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects the filter to the device.  <a href="#ad23edec9e874cebcb68cd358fd321dea">More...</a><br /></td></tr>
<tr class="separator:ad23edec9e874cebcb68cd358fd321dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621b5142b717037b322be3c9e1ee93e5"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a621b5142b717037b322be3c9e1ee93e5">get_SourceCount</a> (int *sourcecount)</td></tr>
<tr class="memdesc:a621b5142b717037b322be3c9e1ee93e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many sources are available on the device currently controlled.  <a href="#a621b5142b717037b322be3c9e1ee93e5">More...</a><br /></td></tr>
<tr class="separator:a621b5142b717037b322be3c9e1ee93e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2425459859405146faf689043b2bf3"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a4c2425459859405146faf689043b2bf3">get_SourceName</a> (int aIndex, BSTR *sourcename)</td></tr>
<tr class="memdesc:a4c2425459859405146faf689043b2bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of one of the sources of the device currently controlled.  <a href="#a4c2425459859405146faf689043b2bf3">More...</a><br /></td></tr>
<tr class="separator:a4c2425459859405146faf689043b2bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847497e6ae3a1b5bfbd20bb3106fcf9e"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a847497e6ae3a1b5bfbd20bb3106fcf9e">get_Source</a> (BSTR *source)</td></tr>
<tr class="memdesc:a847497e6ae3a1b5bfbd20bb3106fcf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the source currently selected on the device read method.  <a href="#a847497e6ae3a1b5bfbd20bb3106fcf9e">More...</a><br /></td></tr>
<tr class="separator:a847497e6ae3a1b5bfbd20bb3106fcf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d82ae72232172428829035bb51242d9"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a1d82ae72232172428829035bb51242d9">put_Source</a> (BSTR source)</td></tr>
<tr class="memdesc:a1d82ae72232172428829035bb51242d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the source currently selected on the device write method.  <a href="#a1d82ae72232172428829035bb51242d9">More...</a><br /></td></tr>
<tr class="separator:a1d82ae72232172428829035bb51242d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6054ddeeb821d93562be5f2e42060ed6"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a6054ddeeb821d93562be5f2e42060ed6">get_Channel</a> (int *channel)</td></tr>
<tr class="memdesc:a6054ddeeb821d93562be5f2e42060ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming channel read method.  <a href="#a6054ddeeb821d93562be5f2e42060ed6">More...</a><br /></td></tr>
<tr class="separator:a6054ddeeb821d93562be5f2e42060ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40874c6b8fb91e268a908d215175d18"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ad40874c6b8fb91e268a908d215175d18">put_Channel</a> (int channel)</td></tr>
<tr class="memdesc:ad40874c6b8fb91e268a908d215175d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming channel write method.  <a href="#ad40874c6b8fb91e268a908d215175d18">More...</a><br /></td></tr>
<tr class="separator:ad40874c6b8fb91e268a908d215175d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61f0b34214b7c1520027d36124d49e5"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ab61f0b34214b7c1520027d36124d49e5">get_BufferCount</a> (int *count)</td></tr>
<tr class="memdesc:ab61f0b34214b7c1520027d36124d49e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer count read method.  <a href="#ab61f0b34214b7c1520027d36124d49e5">More...</a><br /></td></tr>
<tr class="separator:ab61f0b34214b7c1520027d36124d49e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb2119b9980e1a89edb64bb10d99f2b"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#afdb2119b9980e1a89edb64bb10d99f2b">put_BufferCount</a> (int count)</td></tr>
<tr class="memdesc:afdb2119b9980e1a89edb64bb10d99f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer count write method.  <a href="#afdb2119b9980e1a89edb64bb10d99f2b">More...</a><br /></td></tr>
<tr class="separator:afdb2119b9980e1a89edb64bb10d99f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761a4620d6ba4f23bc4a31dc8f634079"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a761a4620d6ba4f23bc4a31dc8f634079">get_DefaultBufferSize</a> (int *size)</td></tr>
<tr class="memdesc:a761a4620d6ba4f23bc4a31dc8f634079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default buffer size read method.  <a href="#a761a4620d6ba4f23bc4a31dc8f634079">More...</a><br /></td></tr>
<tr class="separator:a761a4620d6ba4f23bc4a31dc8f634079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d1e186ba818ad7ed26cc19d96a4fda"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ac5d1e186ba818ad7ed26cc19d96a4fda">put_DefaultBufferSize</a> (int size)</td></tr>
<tr class="memdesc:ac5d1e186ba818ad7ed26cc19d96a4fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default buffer size write method.  <a href="#ac5d1e186ba818ad7ed26cc19d96a4fda">More...</a><br /></td></tr>
<tr class="separator:ac5d1e186ba818ad7ed26cc19d96a4fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8ee42aef935cf1667fb8f82ad47561"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a8b8ee42aef935cf1667fb8f82ad47561">get_DropThreshold</a> (int *threshold)</td></tr>
<tr class="memdesc:a8b8ee42aef935cf1667fb8f82ad47561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop threshold read method.  <a href="#a8b8ee42aef935cf1667fb8f82ad47561">More...</a><br /></td></tr>
<tr class="separator:a8b8ee42aef935cf1667fb8f82ad47561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb52ffcb015080317dc7a7cac590e4fe"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#acb52ffcb015080317dc7a7cac590e4fe">put_DropThreshold</a> (int threshold)</td></tr>
<tr class="memdesc:acb52ffcb015080317dc7a7cac590e4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop threshold write method.  <a href="#acb52ffcb015080317dc7a7cac590e4fe">More...</a><br /></td></tr>
<tr class="separator:acb52ffcb015080317dc7a7cac590e4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7a376fda2e91f7f56a2ed6ac3ceac0"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#aab7a376fda2e91f7f56a2ed6ac3ceac0">get_Width</a> (int *width)</td></tr>
<tr class="memdesc:aab7a376fda2e91f7f56a2ed6ac3ceac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image format width read method.  <a href="#aab7a376fda2e91f7f56a2ed6ac3ceac0">More...</a><br /></td></tr>
<tr class="separator:aab7a376fda2e91f7f56a2ed6ac3ceac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36198e07dc29d7984d78f04c5b86392"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#aa36198e07dc29d7984d78f04c5b86392">put_Width</a> (int width)</td></tr>
<tr class="memdesc:aa36198e07dc29d7984d78f04c5b86392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image format width write method.  <a href="#aa36198e07dc29d7984d78f04c5b86392">More...</a><br /></td></tr>
<tr class="separator:aa36198e07dc29d7984d78f04c5b86392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d5227ba9d401ac5e3fd6e0bf144132"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a29d5227ba9d401ac5e3fd6e0bf144132">get_Height</a> (int *height)</td></tr>
<tr class="memdesc:a29d5227ba9d401ac5e3fd6e0bf144132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image format height read method.  <a href="#a29d5227ba9d401ac5e3fd6e0bf144132">More...</a><br /></td></tr>
<tr class="separator:a29d5227ba9d401ac5e3fd6e0bf144132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7132a3075715700d178e17fb9768a8"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a1a7132a3075715700d178e17fb9768a8">put_Height</a> (int height)</td></tr>
<tr class="memdesc:a1a7132a3075715700d178e17fb9768a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image format height write method.  <a href="#a1a7132a3075715700d178e17fb9768a8">More...</a><br /></td></tr>
<tr class="separator:a1a7132a3075715700d178e17fb9768a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726ef26d053b8ab29ae2dd36ff659cc8"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a726ef26d053b8ab29ae2dd36ff659cc8">get_ParametersSelector</a> (int *selector)</td></tr>
<tr class="memdesc:a726ef26d053b8ab29ae2dd36ff659cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently active GenICam interface read method.  <a href="#a726ef26d053b8ab29ae2dd36ff659cc8">More...</a><br /></td></tr>
<tr class="separator:a726ef26d053b8ab29ae2dd36ff659cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac108e0b0ef36c9df7eda66b47216e16d"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ac108e0b0ef36c9df7eda66b47216e16d">put_ParametersSelector</a> (int selector)</td></tr>
<tr class="memdesc:ac108e0b0ef36c9df7eda66b47216e16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently active GenICam interface write method.  <a href="#ac108e0b0ef36c9df7eda66b47216e16d">More...</a><br /></td></tr>
<tr class="separator:ac108e0b0ef36c9df7eda66b47216e16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b68e7b694659450380cf3ed4ae15ced"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a5b68e7b694659450380cf3ed4ae15ced">get_ParametersAvailable</a> (BOOL *available)</td></tr>
<tr class="memdesc:a5b68e7b694659450380cf3ed4ae15ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently active GenICam interface availability method.  <a href="#a5b68e7b694659450380cf3ed4ae15ced">More...</a><br /></td></tr>
<tr class="separator:a5b68e7b694659450380cf3ed4ae15ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e01caa2f405efb1c5baa80c688c27b6"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a7e01caa2f405efb1c5baa80c688c27b6">get_ParameterCount</a> (int *count)</td></tr>
<tr class="memdesc:a7e01caa2f405efb1c5baa80c688c27b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently active GenICam interface parameter count method.  <a href="#a7e01caa2f405efb1c5baa80c688c27b6">More...</a><br /></td></tr>
<tr class="separator:a7e01caa2f405efb1c5baa80c688c27b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883862021e259302ab8df2457010f51e"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a883862021e259302ab8df2457010f51e">get_ParameterName</a> (int index, BSTR *name)</td></tr>
<tr class="memdesc:a883862021e259302ab8df2457010f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the parameter at a specific index in the currently selected GenICam interface.  <a href="#a883862021e259302ab8df2457010f51e">More...</a><br /></td></tr>
<tr class="separator:a883862021e259302ab8df2457010f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85abdce08134adca70ef8d05d5120122"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a85abdce08134adca70ef8d05d5120122">get_ParameterCategory</a> (BSTR name, BSTR *category)</td></tr>
<tr class="memdesc:a85abdce08134adca70ef8d05d5120122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Category of a parameter identified by its name for the currently selected GenICam interface.  <a href="#a85abdce08134adca70ef8d05d5120122">More...</a><br /></td></tr>
<tr class="separator:a85abdce08134adca70ef8d05d5120122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47abc5f944f452947a4f5c43bac6d3c4"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a47abc5f944f452947a4f5c43bac6d3c4">get_ParameterValue</a> (BSTR name, BSTR *value)</td></tr>
<tr class="memdesc:a47abc5f944f452947a4f5c43bac6d3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method used to read the value of a specific parameter as a string for the currently selected GenICam interface.  <a href="#a47abc5f944f452947a4f5c43bac6d3c4">More...</a><br /></td></tr>
<tr class="separator:a47abc5f944f452947a4f5c43bac6d3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebdd0223cb8238941082b229f99bfb2"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a8ebdd0223cb8238941082b229f99bfb2">put_ParameterValue</a> (BSTR name, BSTR value, BSTR *message)</td></tr>
<tr class="memdesc:a8ebdd0223cb8238941082b229f99bfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method used to write the value of a specific parameter as a string for the currently selected GenICam interface.  <a href="#a8ebdd0223cb8238941082b229f99bfb2">More...</a><br /></td></tr>
<tr class="separator:a8ebdd0223cb8238941082b229f99bfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ce86dd26cf576559ffaa8ca7e4ffb"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a3b1ce86dd26cf576559ffaa8ca7e4ffb">get_ParameterType</a> (BSTR name, BSTR *type)</td></tr>
<tr class="memdesc:a3b1ce86dd26cf576559ffaa8ca7e4ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a parameter identified by its name for the currently selected GenICam interface.  <a href="#a3b1ce86dd26cf576559ffaa8ca7e4ffb">More...</a><br /></td></tr>
<tr class="separator:a3b1ce86dd26cf576559ffaa8ca7e4ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cbf48854e78bcd8c2a2f34e0d73d3c"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a28cbf48854e78bcd8c2a2f34e0d73d3c">get_ParameterAccess</a> (THIS_ BSTR name, BOOL *available, BOOL *readable, BOOL *writable)</td></tr>
<tr class="memdesc:a28cbf48854e78bcd8c2a2f34e0d73d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current access mode for a parameter identified by its name for the currently selected GenICam interface.  <a href="#a28cbf48854e78bcd8c2a2f34e0d73d3c">More...</a><br /></td></tr>
<tr class="separator:a28cbf48854e78bcd8c2a2f34e0d73d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fd63ffadb35573e299d18f2e73cf71"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ab1fd63ffadb35573e299d18f2e73cf71">ParameterExecute</a> (BSTR name, BSTR *message)</td></tr>
<tr class="memdesc:ab1fd63ffadb35573e299d18f2e73cf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a command parameter identified by its name for the currently selected GenICam interface.  <a href="#ab1fd63ffadb35573e299d18f2e73cf71">More...</a><br /></td></tr>
<tr class="separator:ab1fd63ffadb35573e299d18f2e73cf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80984d91d85789d132c01d49fae02f8"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#ab80984d91d85789d132c01d49fae02f8">get_ParameterPossibleValueCount</a> (BSTR name, int *count)</td></tr>
<tr class="memdesc:ab80984d91d85789d132c01d49fae02f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of possible values for an enum or Boolean parameter identified by its name for the currently selected GenICam interface.  <a href="#ab80984d91d85789d132c01d49fae02f8">More...</a><br /></td></tr>
<tr class="separator:ab80984d91d85789d132c01d49fae02f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2222b562922a746ab48a99a5f1b670"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#add2222b562922a746ab48a99a5f1b670">get_ParameterPossibleValue</a> (BSTR name, int index, BSTR *value)</td></tr>
<tr class="memdesc:add2222b562922a746ab48a99a5f1b670"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the possible values for an enum or Boolean parameter identified by its name for the currently selected GenICam interface.  <a href="#add2222b562922a746ab48a99a5f1b670">More...</a><br /></td></tr>
<tr class="separator:add2222b562922a746ab48a99a5f1b670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61284953bcc6db3eb3967c11bfbca2a0"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_d_s_source.html#a61284953bcc6db3eb3967c11bfbca2a0">get_ParameterVisibility</a> (BSTR name, int *visibility)</td></tr>
<tr class="memdesc:a61284953bcc6db3eb3967c11bfbca2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visibility of a parameter identified by its name for the currently selected GenICam interface.  <a href="#a61284953bcc6db3eb3967c11bfbca2a0">More...</a><br /></td></tr>
<tr class="separator:a61284953bcc6db3eb3967c11bfbca2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>COM interface to the eBUS SDK DirectShow Source filter, <a class="el" href="class_pv_d_s_source.html">PvDSSource</a>. </p>
<p>When you have instantiated a <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> DirectShow filter, you can retrieve the <a class="el" href="class_i_pv_d_s_source.html" title="COM interface to the eBUS SDK DirectShow Source filter, PvDSSource. ">IPvDSSource</a> configuration interface by using QueryInterface on any interface of the object. Remember to always release interfaces when finished with them to avoid resource leaks.</p>
<p>The documentation of this interface assumes good knowledge of DirectShow by the reader.</p>
<p>To configure (and use) your <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter, typically:</p><ul>
<li>Create the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter</li>
<li>Retrieve a <a class="el" href="class_i_pv_d_s_source.html" title="COM interface to the eBUS SDK DirectShow Source filter, PvDSSource. ">IPvDSSource</a> configuration interface from the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter</li>
<li>Configure the filter (select the device, set parameters, connect the device)</li>
<li>Instantiate your other DirectShow filters</li>
<li>Add your DirectShow filters to a DirectShow graph</li>
<li>Connect your DirectShow filters</li>
<li>Run your DirectShow graph</li>
</ul>
<p>From prototyping, you can interact with the filter using GraphEdit:</p><ul>
<li>Create the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter</li>
<li>Open the property pages of the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter</li>
<li>Configure the filter (select the device, set parameters, connect the device)</li>
<li>Instantiate other filters (display, video compressor, file writer, etc.)</li>
<li>Connect the filters</li>
<li>Run your DirectShow graph</li>
</ul>
<p>It is important to connect the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter to the device BEFORE connecting it to other DirectShow filters. Doing so will adjust the filter width, height and other key parameters that are expected to stay fixed by filters you connect to your <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter.</p>
<p>The <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter supports pins reconfiguration when its configuration changes. However we found through our experiments that not all filters like having their configuration changed on the fly. It is recommend to design for changing width and height of the source when not connected to an other filter.</p>
<p>If you are using the unicast or multicast mode (GigE Vision only) you should manually (or programmatically) set the width and the height of the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter before connecting it to other filters.</p>
<p>The GUID of the filter is defined as IID_IPvDSSource {7D692BC5-05D4-4032-A581-B7FA1C202825}. You can include it in your own project through <a class="el" href="_pv_d_s_source_u_i_ds_8h_source.html">PvDSSourceUIDs.h</a> or redefine it from this GUID.</p>
<p>You can look at the eBUS SDK DirectShowDisplay (available for C++ and C#) samples for examples of how to use the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter to link GigE Vision or USB3 Vision image streams to a DirectShow display.</p>
<h2>Roles</h2>
<p>The filter can be used in three different modes, or roles.</p>
<h3>Control and data-receiver mode</h3>
<p>The filter takes control of the device and receives images from the same device. This mode can be used with GigE Vision devices and USB3 Vision devices. To configure the filter for this mode, just assign the device ID. With this mode, the filter is responsible of controlling when the device starts and stops streaming.</p>
<h3>Unicast mode</h3>
<p>The filter is just a data receiver that receives images from a GigE Vision device. The device is typically controlled by a <a class="el" href="class_pv_device_g_e_v.html" title="Connect, configure and control a GigE Vision device. ">PvDeviceGEV</a> which can exist in the same process, a different process or even a different computer. Some devices in autonomous streaming modes could also be used. To configure the filter for this mode, assign the device ID and and unicast port. Make sure your device is configured to stream to your local interface on this port. With this mode, you are responsible of making sure the' device starts and stops streaming. The filter is just a passive receiver.</p>
<h3>Multicast mode</h3>
<p>Just like unicast mode but instead of the data being sent to a unique IP/port address, the data is being multicast to a group joined by the filter. With this mode, more than one DirectShow filter or GigE Vision receiver can listen in on transmitted images. To use this mode, assign the device ID, multicast group address and port. Make sure your device is configured to stream to this multicast group. Just like the unicast mode, the filter is just a passive receiver: you are responsible of making sure it starts and stops streaming.</p>
<h2>Persistence</h2>
<p>The <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter implements the IPersistStream COM interface. This enables saving the filter configuration to a DirectShow graph persistence file. When the file is read back the filter is automatically configured and connected to the device it was using when its state was persisted. All filter configuration parameter are persisted. GenICam interfaces (communication, control and stream) are also persisted if applicable.</p>
<p>This enables the user from saving a graph state from GraphEdit. This capability can also be used programmatically using the DirectShow graph COM interface.</p>
<h2>GenICam interfaces</h2>
<p>The filter exposes the GenICam interfaces of some internal components: the controller communication parameters (control mode), the device parameters (control mode) and the stream parameters (all modes).</p>
<p>The API for these GenICam interfaces has been simplified. It should be enough for basic control and statistics monitoring.</p>
<p>The parameter selector property is used to select which GenICam interface is being interacted with. With one GenICam interface selected it is possible to enumerate all parameters, retrieve some properties and get/set the parameter values using simple strings - as would be expected from the <a class="el" href="class_pv_gen_parameter.html" title="Base class for all GenICam feature types. ">PvGenParameter</a> or GenApi "to string" and "from string" capabilities where the value of various parameter types is abstracted to simple strings.</p>
<p>As an example of what can be achieved using the GenICam interface of <a class="el" href="class_i_pv_d_s_source.html" title="COM interface to the eBUS SDK DirectShow Source filter, PvDSSource. ">IPvDSSource</a>, the simplified GenICam browser of the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter is using that API and nothing else. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad23edec9e874cebcb68cd358fd321dea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::ConnectIfNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects the filter to the device. </p>
<p>Calling this method connects the filter to the device if connected device or the way it is connected to does not match the current filter configuration. If the device needs to be connected in a different way the device is first disconnected and then connection is re-established.</p>
<p>The device that is connected is defined using <a class="el" href="class_i_pv_d_s_source.html#a84949035a36cc4e8f405bf6b7813d8f0" title="Device ID write method. ">put_DeviceID</a>. How the device is connected is defined by <a class="el" href="class_i_pv_d_s_source.html#a85f491dcfa596fcd7221cfa1e2af69ad" title="Filter role write method. ">put_Role</a> and role related parameters, the streaming channel and/or the selected source.</p>
<p>Whenever the filter configuration changes in a way that can affect which device or how the device is connected you should call this method to make sure the changes are applied. <a class="el" href="class_i_pv_d_s_source.html#a84949035a36cc4e8f405bf6b7813d8f0" title="Device ID write method. ">put_DeviceID</a>, <a class="el" href="class_i_pv_d_s_source.html#a1d82ae72232172428829035bb51242d9" title="Name of the source currently selected on the device write method. ">put_Source</a>, <a class="el" href="class_i_pv_d_s_source.html#ad40874c6b8fb91e268a908d215175d18" title="Streaming channel write method. ">put_Channel</a>, <a class="el" href="class_i_pv_d_s_source.html#a85f491dcfa596fcd7221cfa1e2af69ad" title="Filter role write method. ">put_Role</a>, <a class="el" href="class_i_pv_d_s_source.html#a6b8a38ae6574f0b11733dae9e4608a30" title="Filter unicast port write method. ">put_UnicastPort</a>, <a class="el" href="class_i_pv_d_s_source.html#ac13c58ceca470e3aa01723301bc7087c" title="Filter multicast group IP address write method. ">put_MulticastIP</a>, <a class="el" href="class_i_pv_d_s_source.html#a56dd7e33c089adad5afa292cdca12722" title="Multicast group port to join where the streaming data from the GigE Vision device is received with th...">put_MulticastPort</a> can affect connectivity.</p>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cad3fb2dd7cfdd886f5c65ed77b7a38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::DisconnectDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects the filter from the device. </p>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ab61f0b34214b7c1520027d36124d49e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_BufferCount </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer count read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#afdb2119b9980e1a89edb64bb10d99f2b" title="Buffer count write method. ">put_BufferCount</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Buffer count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a6054ddeeb821d93562be5f2e42060ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_Channel </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming channel read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#ad40874c6b8fb91e268a908d215175d18" title="Streaming channel write method. ">put_Channel</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">channel</td><td>Streaming channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a761a4620d6ba4f23bc4a31dc8f634079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_DefaultBufferSize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default buffer size read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#ac5d1e186ba818ad7ed26cc19d96a4fda" title="Default buffer size write method. ">put_DefaultBufferSize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Default buffer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ac8a974084539ae42858275ccdfd45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_DeviceID </td>
          <td>(</td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter device ID read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#aac32cf630fea9a3c00d3ff668477fc63" title="Filter diagnostic enabled write method. ">put_DiagnosticEnabled</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">deviceid</td><td>Filter device ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ad712ed75e8f2a04855eb71f8e2af7da6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_DiagnosticEnabled </td>
          <td>(</td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter diagnostic enabled read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#aac32cf630fea9a3c00d3ff668477fc63" title="Filter diagnostic enabled write method. ">put_DiagnosticEnabled</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">enabled</td><td>Filter diagnostic enabled state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8ee42aef935cf1667fb8f82ad47561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_DropThreshold </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop threshold read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#acb52ffcb015080317dc7a7cac590e4fe" title="Drop threshold write method. ">put_DropThreshold</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">threshold</td><td>Drop threshold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a29d5227ba9d401ac5e3fd6e0bf144132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_Height </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter image format height read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#aab7a376fda2e91f7f56a2ed6ac3ceac0" title="Filter image format width read method. ">get_Width</a>, <a class="el" href="class_i_pv_d_s_source.html#aa36198e07dc29d7984d78f04c5b86392" title="Filter image format width write method. ">put_Width</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>Filter image format height.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aa287307eaa89d91eafe9f83573003fe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_MulticastIP </td>
          <td>(</td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter multicast group IP address read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#ac13c58ceca470e3aa01723301bc7087c" title="Filter multicast group IP address write method. ">put_MulticastIP</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ip</td><td>Filter multicast IP address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9f68fa9ab55eab43dc6c7ea5d11c526"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_MulticastPort </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter multicast group port read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#a56dd7e33c089adad5afa292cdca12722" title="Multicast group port to join where the streaming data from the GigE Vision device is received with th...">put_MulticastPort</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">port</td><td>Filter multicast port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a28cbf48854e78bcd8c2a2f34e0d73d3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterAccess </td>
          <td>(</td>
          <td class="paramtype">THIS_ BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>available</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>readable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>writable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current access mode for a parameter identified by its name for the currently selected GenICam interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">available</td><td>True if the parameter is currently available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">readable</td><td>True if the parameter is currently readable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">writable</td><td>True if the parameter is currently writable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available</li>
<li>E_INVALIDARG if the parameter name is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a85abdce08134adca70ef8d05d5120122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterCategory </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>category</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Category of a parameter identified by its name for the currently selected GenICam interface. </p>
<p>See <a class="el" href="class_pv_gen_parameter_array.html#a60f822069877f4b98164e5e77432f5a5" title="Get a category (PvGenCategory object) from the array (using array position). ">PvGenParameterArray::GetCategory</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">category</td><td>Category of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available</li>
<li>E_INVALIDARG if the parameter name is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7e01caa2f405efb1c5baa80c688c27b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterCount </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently active GenICam interface parameter count method. </p>
<p>Use this method to obtain how much parameters are available in the currently selected GenICam interface of the filter. This method can be used to iterate through all GenICam parameters using <a class="el" href="class_i_pv_d_s_source.html#a883862021e259302ab8df2457010f51e" title="Name of the parameter at a specific index in the currently selected GenICam interface. ">get_ParameterName</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Parameter count of the currently selected GenICam interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a883862021e259302ab8df2457010f51e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the parameter at a specific index in the currently selected GenICam interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>Index of the parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>Name of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success, E_UNEXPECTED if the parameters are not available, E_INVALIDARG if the index is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="add2222b562922a746ab48a99a5f1b670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterPossibleValue </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One of the possible values for an enum or Boolean parameter identified by its name for the currently selected GenICam interface. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#ab80984d91d85789d132c01d49fae02f8" title="Count of possible values for an enum or Boolean parameter identified by its name for the currently se...">get_ParameterPossibleValueCount</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the possible value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Requested possible value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available</li>
<li>E_INVALIDARG if the index is not valid</li>
<li>E_UNEXPECTED if the parameter is not found or has not possible values. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab80984d91d85789d132c01d49fae02f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterPossibleValueCount </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count of possible values for an enum or Boolean parameter identified by its name for the currently selected GenICam interface. </p>
<p>This method only applies to enum and Boolean parameters. It is typically used with <a class="el" href="class_i_pv_d_s_source.html#add2222b562922a746ab48a99a5f1b670" title="One of the possible values for an enum or Boolean parameter identified by its name for the currently ...">get_ParameterPossibleValue</a> in order to populate a combobox with all possible values the parameter can take.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Possible value count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5b68e7b694659450380cf3ed4ae15ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParametersAvailable </td>
          <td>(</td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>available</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently active GenICam interface availability method. </p>
<p>If the active/selected GenICam interface is:</p><ul>
<li>0: device controller communication parameters: evaluates to true if the device controller is instantiated</li>
<li>1: device controller device parameters: evaluates to true if the device controller is instantiated and connected</li>
<li>2: stream object parameters and statistics: evaluates to true if the stream object is opened</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">available</td><td>True if the currently selected GenICam interface is active.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a726ef26d053b8ab29ae2dd36ff659cc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParametersSelector </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently active GenICam interface read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#ac108e0b0ef36c9df7eda66b47216e16d" title="Currently active GenICam interface write method. ">put_ParametersSelector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selector</td><td>Currently active GenICam interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b1ce86dd26cf576559ffaa8ca7e4ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterType </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a parameter identified by its name for the currently selected GenICam interface. </p>
<p>Possible values:</p><ul>
<li>Integer</li>
<li>Enum</li>
<li>Boolean</li>
<li>String</li>
<li>Command</li>
<li>Float</li>
<li>Register</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>String representing the parameter type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available</li>
<li>E_INVALIDARG if the parameter name is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a47abc5f944f452947a4f5c43bac6d3c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterValue </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method used to read the value of a specific parameter as a string for the currently selected GenICam interface. </p>
<p>See PvGenParameterArray::FromString for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available</li>
<li>E_INVALIDARG if the parameter name is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a61284953bcc6db3eb3967c11bfbca2a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_ParameterVisibility </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visibility of a parameter identified by its name for the currently selected GenICam interface. </p>
<p>The visibility of the parameter is expressed as an integer:</p><ul>
<li>0: Beginner</li>
<li>1: Expert</li>
<li>2: Guru</li>
<li>3: Invisible</li>
</ul>
<p>See <a class="el" href="class_i_pv_d_s_source.html#ab80984d91d85789d132c01d49fae02f8" title="Count of possible values for an enum or Boolean parameter identified by its name for the currently se...">get_ParameterPossibleValueCount</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">visibility</td><td>Visibility of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available</li>
<li>E_INVALIDARG if the parameter name is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a27790b0f348b4c1216b3d15fdd8a943c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_Role </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter role read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#a85f491dcfa596fcd7221cfa1e2af69ad" title="Filter role write method. ">put_Role</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">role</td><td>Filter role.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a847497e6ae3a1b5bfbd20bb3106fcf9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_Source </td>
          <td>(</td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the source currently selected on the device read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#a1d82ae72232172428829035bb51242d9" title="Name of the source currently selected on the device write method. ">put_Source</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">source</td><td>Name of the active source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a621b5142b717037b322be3c9e1ee93e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_SourceCount </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sourcecount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many sources are available on the device currently controlled. </p>
<p>This parameter and <a class="el" href="class_i_pv_d_s_source.html#a4c2425459859405146faf689043b2bf3" title="Name of one of the sources of the device currently controlled. ">get_SourceName</a> can be used to retrieve all available sources and present the user with a list or combo box where the active source can be selected.</p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#a1d82ae72232172428829035bb51242d9" title="Name of the source currently selected on the device write method. ">put_Source</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sourcecount</td><td>How many sources the currently controlled device has.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c2425459859405146faf689043b2bf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_SourceName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>sourcename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of one of the sources of the device currently controlled. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#a1d82ae72232172428829035bb51242d9" title="Name of the source currently selected on the device write method. ">put_Source</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Zero-based index of the source. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sourcename</td><td>Name of the source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e94d5e42b57f5fd11e0e73a94978d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_UnicastPort </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter unicast port read method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#a6b8a38ae6574f0b11733dae9e4608a30" title="Filter unicast port write method. ">put_UnicastPort</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">port</td><td>Filter unicast port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aab7a376fda2e91f7f56a2ed6ac3ceac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::get_Width </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter image format width read method. </p>
<p>The user can set the image format width using <a class="el" href="class_i_pv_d_s_source.html#aa36198e07dc29d7984d78f04c5b86392" title="Filter image format width write method. ">put_Width</a> but this value can automatically be adjusted when the controlled device is connected or when the width is being changed on the controlled device.</p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#aa36198e07dc29d7984d78f04c5b86392" title="Filter image format width write method. ">put_Width</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>Filter image format width.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1fd63ffadb35573e299d18f2e73cf71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::ParameterExecute </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a command parameter identified by its name for the currently selected GenICam interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>On failure, contains the GenICam/GenApi error message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success, E_UNEXPECTED if the parameters are not available, E_INVALIDARG if the parameter name is not found, E_FAIL if executing the command failed. </dd></dl>

</div>
</div>
<a class="anchor" id="afdb2119b9980e1a89edb64bb10d99f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_BufferCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer count write method. </p>
<p>This parameter controls how many image buffers are used internally by the eBUS SDK <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter when receiving data.</p>
<p>Setting the buffer count does immediately changes the effective buffer count. <a class="el" href="class_i_pv_d_s_source.html#ad23edec9e874cebcb68cd358fd321dea" title="Connects the filter to the device. ">ConnectIfNeeded</a> must be called in order to apply the change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>buffer count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ad40874c6b8fb91e268a908d215175d18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_Channel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming channel write method. </p>
<p>This parameter controls which streaming channel is used when receiving data with the unicast or multicast roles. It is not applicable with the controller and data-receiver role when it is automatically configured.</p>
<p>It is highly recommended to set this parameter when using unicast or multicast roles. Streaming will still work if not defined but resend packets may not work as expected if the channel is different than 0.</p>
<p>Setting the channel does immediately make the new channel active. <a class="el" href="class_i_pv_d_s_source.html#ad23edec9e874cebcb68cd358fd321dea" title="Connects the filter to the device. ">ConnectIfNeeded</a> must be called in order to apply the change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>Streaming channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5d1e186ba818ad7ed26cc19d96a4fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_DefaultBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default buffer size write method. </p>
<p>This parameter defines the default buffer size used to allocate the internal image buffers when the filter cannot read the effective payload size on the device. This can happen if the device does not properly implement the GigE Vision specific (unexpected) or if the role is set to unicast or multicast and the device is not being controlled by the filter.</p>
<p>This parameter is used if the effective payload size cannot be obtained, every time the DirectShow filter graph is started.</p>
<p>If the buffers cannot be properly allocated and the default buffer size is not large enough to accommodate incoming images the filter will automatically resize its internal buffers accordingly. However, some BUFFER_TOO_SMALL errors will be recorded and the first few images coming from the device will never be delivered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Default buffer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a84949035a36cc4e8f405bf6b7813d8f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_DeviceID </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device ID write method. </p>
<p>The device ID is used to connect the device. For a GigE Vision device, provide the MAC or IP address of the device. For a USB3 Vision device, provide the GUID of the device. You can also use the <a class="el" href="class_pv_device_info.html#abb19028d7298d5a4cfd2a83f2ec78011" title="Get a unique string identifying this device for connection purpose. ">PvDeviceInfo::GetConnectionID</a> method if you are using <a class="el" href="class_pv_system.html" title="Find interfaces (network adapters or USB host controllers) and devices reachable from this PC...">PvSystem</a> or <a class="el" href="class_pv_device_finder_wnd.html" title="A user interface that finds all GigE Vision, USB3 Vision and Pleora Protocol devices on a network and...">PvDeviceFinderWnd</a> to detect and select the device of interest.</p>
<p>The device is connected when the ConnectIfNeeded method is called. Changing the device ID does not connect the filter to a device, it is just stored for the next ConnectIfNeeded operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceid</td><td>Filter device ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aac32cf630fea9a3c00d3ff668477fc63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_DiagnosticEnabled </td>
          <td>(</td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter diagnostic enabled write method. </p>
<p>When the diagnostic mode is enabled, statistics and other information about the state of the filter are drawn over the images output by the filter. It can be useful to diagnose why you are not getting images or why the images are not formatted as expected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>Filter diagnostic enabled state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="acb52ffcb015080317dc7a7cac590e4fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_DropThreshold </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop threshold write method. </p>
<p>Threshold used by the filter to internally drop incoming images. The upstream filter(s) are asking the source filter to deliver data at their own pace. If buffers keep arriving from the device to the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter, they accumulate without being delivered to the connected filters.</p>
<p>This parameter defines the threshold of ready images above which the filter will drop images until delivering an image when asked for one by the downstream filter.</p>
<p>Example: if set at 4 and the downstream filter (display, compressor, etc.) asks for an image and 7 images are available the filter will drop the 3 oldest images before delivering.</p>
<p>No one wants to drop images but in DirectShow as a source filter we do not control the rate at which the downstream filter asks for images. This parameter can be used to minimize latency.</p>
<p>Setting this parameter to 0 disables image dropping at the filter level.</p>
<p>If the filter runs out of available image buffer images may be dropped internally at the acquisition pipeline level. It is also possible that if the device is not able to transmit images quickly enough that images maybe be dropped at the device/grabber level as well. Counters on these three "drop" gates are available in the filter diagnostics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Drop threshold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a7132a3075715700d178e17fb9768a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_Height </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter image format height write method. </p>
<p>See <a class="el" href="class_i_pv_d_s_source.html#aab7a376fda2e91f7f56a2ed6ac3ceac0" title="Filter image format width read method. ">get_Width</a>, <a class="el" href="class_i_pv_d_s_source.html#aa36198e07dc29d7984d78f04c5b86392" title="Filter image format width write method. ">put_Width</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Filter image format height.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ac13c58ceca470e3aa01723301bc7087c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_MulticastIP </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter multicast group IP address write method. </p>
<p>Multicast group IP address to join where the streaming data from the GigE Vision device is received with the multicast role.</p>
<p>The user has to make sure the GigE Vision device is configured to send data to that multicast group. This is typically performed using the eBUS Player multicast mode (setup dialog) or the <a class="el" href="class_pv_device_g_e_v.html#ac308619e22f6a21e471fe0e1b7e57b56" title="Set the UDP/IP destination to which the GigE Vision device transmits data. ">PvDeviceGEV::SetStreamDestination</a> method.</p>
<p>The filter multicast group IP address is only considered when connecting the device with the role defined as multicast receiver for GigE Vision devices. The device is connected when the ConnectIfNeeded method is called.</p>
<p>This parameter is usually set in pair with <a class="el" href="class_i_pv_d_s_source.html#a56dd7e33c089adad5afa292cdca12722" title="Multicast group port to join where the streaming data from the GigE Vision device is received with th...">put_MulticastPort</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ip</td><td>Filter multicast IP address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a56dd7e33c089adad5afa292cdca12722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_MulticastPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multicast group port to join where the streaming data from the GigE Vision device is received with the multicast role. </p>
<p>The user has to make sure the GigE Vision device is configured to send data to that multicast group. This is typically performed using the eBUS Player multicast mode (setup dialog) or the <a class="el" href="class_pv_device_g_e_v.html#ac308619e22f6a21e471fe0e1b7e57b56" title="Set the UDP/IP destination to which the GigE Vision device transmits data. ">PvDeviceGEV::SetStreamDestination</a> method.</p>
<p>The filter multicast group port is only considered when connecting the device with the role defined as multicast receiver for GigE Vision devices. The device is connected when the ConnectIfNeeded method is called.</p>
<p>This parameter is usually set in pair with <a class="el" href="class_i_pv_d_s_source.html#ac13c58ceca470e3aa01723301bc7087c" title="Filter multicast group IP address write method. ">put_MulticastIP</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Filter unicast port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ac108e0b0ef36c9df7eda66b47216e16d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_ParametersSelector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently active GenICam interface write method. </p>
<p>This method selects the active GenICam interface for the internal filter objects:</p><ul>
<li>0: the device controller communication parameters (controller and data receiver-mode only)</li>
<li>1: the device controller device parameters (controller and data receiver-mode only)</li>
<li>2: the stream object parameters and statistics</li>
</ul>
<p>All the GenICam parameter operations are performed on the currently active/selected GenICam interface. The active GenICam interface is selecting using this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">selector</td><td>Currently active GenICam interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_FAIL if out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8ebdd0223cb8238941082b229f99bfb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_ParameterValue </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSTR *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method used to write the value of a specific parameter as a string for the currently selected GenICam interface. </p>
<p>See PvGenParameterArray::ToString for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>New value of the parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>On failure, contains the GenICam/GenApi error message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success<ul>
<li>E_UNEXPECTED if the parameters are not available</li>
<li>E_INVALIDARG if the parameter name is not found</li>
<li>E_FAIL if the write operation failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a85f491dcfa596fcd7221cfa1e2af69ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_Role </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter role write method. </p>
<p>The role of the filter can be:</p><ul>
<li>0: controller and data-receiver (supports GigE Vision and USB3 Vision)</li>
<li>1: unicast receiver (GigE Vision only)</li>
<li>2: multicast receiver (GigE Vision only)</li>
</ul>
<p>The filter role is only considered when connecting the device. The device is connected when the ConnectIfNeeded method is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">role</td><td>Filter role.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d82ae72232172428829035bb51242d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_Source </td>
          <td>(</td>
          <td class="paramtype">BSTR&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the source currently selected on the device write method. </p>
<p>This parameter only applies to multi-sources devices. It should simply be left blank on devices having a single source.</p>
<p>Setting the source does immediately make the source active. <a class="el" href="class_i_pv_d_s_source.html#ad23edec9e874cebcb68cd358fd321dea" title="Connects the filter to the device. ">ConnectIfNeeded</a> must be called in order to apply the change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Name of the active source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b8a38ae6574f0b11733dae9e4608a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_UnicastPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter unicast port write method. </p>
<p>Unicast port where the streaming data from the GigE Vision device is received with the unicast role. A socket bound to the network interface that can reach the device is configured to listen for incoming images on that port.</p>
<p>The user has to make sure the GigE Vision device is configured to send data to the IP address of that local interface and at that unicast port. This is typically performed using the eBUS Player unicast mode (setup dialog) or the <a class="el" href="class_pv_device_g_e_v.html#ac308619e22f6a21e471fe0e1b7e57b56" title="Set the UDP/IP destination to which the GigE Vision device transmits data. ">PvDeviceGEV::SetStreamDestination</a> method.</p>
<p>The filter unicast port is only considered when connecting the device with the role defined as unicast receiver for GigE Vision devices. The device is connected when the ConnectIfNeeded method is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Filter unicast port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aa36198e07dc29d7984d78f04c5b86392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT IPvDSSource::put_Width </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter image format width write method. </p>
<p>The width and height is usually automatically managed by the filter when connecting to a device which is being controlled - when the role is set to controller and data receiver.</p>
<p>If the filter is being used in a data receiver role (unicast or multicast) the width and height must be set by the user before using the filter. It is highly recommended to set the width and height before connecting the <a class="el" href="class_pv_d_s_source.html">PvDSSource</a> filter to other filters.</p>
<p>Width/height mismatched can be debugged using the filter diagnostics. Typically if the configured image size is larger than what is received the image data will be provided to the downstream filter in the upper-left corner with black bands on the right and bottom. If the configured image size is too small black images are output by the filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Filter image format width.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOERROR on success. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>IPvDSSource.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2018 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
